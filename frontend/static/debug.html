<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Backend debug console</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			html,
			body {
				height: 100%;
				background: #0c0c0c;
				color: #cccccc;
				font-family: monospace;
				font-size: 14px;
			}
			#toolbar {
				background: #1e1e1e;
				border-bottom: 1px solid #333;
				padding: 4px 8px;
				display: flex;
				align-items: center;
				gap: 8px;
				user-select: none;
			}
			#toolbar button {
				background: #333;
				color: #ccc;
				border: 1px solid #555;
				border-radius: 3px;
				padding: 2px 10px;
				cursor: pointer;
				font-size: 12px;
			}
			#toolbar button:hover {
				background: #444;
			}
			#toolbar .status {
				margin-left: auto;
				font-size: 12px;
				color: #888;
			}
			#output {
				height: calc(100% - 30px);
				overflow-y: auto;
				padding: 8px;
				white-space: pre-wrap;
				word-break: break-all;
				line-height: 1.4;
			}
			.line-stderr {
				/* default stderr color when no ANSI override */
				color: #f48771;
			}
			.line-stdout {
				color: #cccccc;
			}
		</style>
	</head>
	<body>
		<div id="toolbar">
			<button id="clearBtn">Clear</button>
			<button id="scrollBtn">Auto-scroll: ON</button>
			<span class="status" id="status">Waiting for backend...</span>
		</div>
		<div id="output"></div>
		<script>
			(async () => {
				const output = document.getElementById('output');
				const status = document.getElementById('status');
				const clearBtn = document.getElementById('clearBtn');
				const scrollBtn = document.getElementById('scrollBtn');
				let autoScroll = true;
				let lineCount = 0;

				clearBtn.addEventListener('click', () => {
					output.innerHTML = '';
					lineCount = 0;
					status.textContent = 'Cleared';
				});

				scrollBtn.addEventListener('click', () => {
					autoScroll = !autoScroll;
					scrollBtn.textContent = 'Auto-scroll: ' + (autoScroll ? 'ON' : 'OFF');
				});

				// ── ANSI-to-HTML converter ──────────────────────────────
				// Standard + bright foreground color palette (Windows Terminal)
				const SGR_FG = {
					30: '#0c0c0c',
					31: '#c50f1f',
					32: '#13a10e',
					33: '#c19c00',
					34: '#0037da',
					35: '#881798',
					36: '#3a96dd',
					37: '#cccccc',
					90: '#767676',
					91: '#e74856',
					92: '#16c60c',
					93: '#f9f1a5',
					94: '#3b78ff',
					95: '#b4009e',
					96: '#61d6d6',
					97: '#f2f2f2',
				};

				function escapeHtml(text) {
					return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
				}

				/**
				 * Convert a raw string containing ANSI SGR escape codes into HTML.
				 * Handles ESC[<codes>m sequences (colors, bold, reset).
				 * Inspired by the ansi_up library (https://github.com/drudru/ansi_up).
				 */
				function ansiToHtml(str) {
					// Match ESC [ <params> m   (ESC = \x1b = char code 27)
					const re = /\x1b\[([0-9;]*)m/g;
					let html = '';
					let lastIndex = 0;
					let fgColor = null;
					let bold = false;
					let match;

					while ((match = re.exec(str)) !== null) {
						// Append escaped text before this sequence
						const preceding = str.slice(lastIndex, match.index);
						if (preceding) {
							html += wrapSpan(preceding, fgColor, bold);
						}

						// Parse SGR codes (e.g. "32" or "1;31" or "0")
						const codes = match[1] === '' ? [0] : match[1].split(';').map(Number);
						for (const code of codes) {
							if (code === 0) {
								fgColor = null;
								bold = false;
							} else if (code === 1) {
								bold = true;
							} else if (code === 22) {
								bold = false;
							} else if (SGR_FG[code]) {
								fgColor = SGR_FG[code];
							}
						}

						lastIndex = re.lastIndex;
					}

					// Remaining text after last escape (or entire string if no escapes)
					const tail = str.slice(lastIndex);
					if (tail) {
						html += wrapSpan(tail, fgColor, bold);
					}

					return html;
				}

				function wrapSpan(text, color, bold) {
					const escaped = escapeHtml(text);
					const parts = [];
					if (color) parts.push('color:' + color);
					if (bold) parts.push('font-weight:bold');
					if (parts.length === 0) return escaped;
					return '<span style="' + parts.join(';') + '">' + escaped + '</span>';
				}
				// ────────────────────────────────────────────────────────

				function appendLine(rawText, isErr) {
					const line = document.createElement('div');
					line.className = isErr ? 'line-stderr' : 'line-stdout';
					line.innerHTML = ansiToHtml(rawText);
					output.appendChild(line);
					lineCount++;
					if (autoScroll) output.scrollTop = output.scrollHeight;
					status.textContent = lineCount + ' lines';
				}

				// Wait for Tauri global API to be injected
				function waitForTauri() {
					return new Promise(resolve => {
						if (window.__TAURI__) return resolve(window.__TAURI__);
						const check = setInterval(() => {
							if (window.__TAURI__) {
								clearInterval(check);
								resolve(window.__TAURI__);
							}
						}, 10);
					});
				}

				const TAURI = await waitForTauri();
				const { listen } = TAURI.event;

				await listen('backend-stdout', e => appendLine(e.payload, false));
				await listen('backend-stderr', e => appendLine(e.payload, true));

				status.textContent = 'Connected, waiting for output...';
			})();
		</script>
	</body>
</html>
